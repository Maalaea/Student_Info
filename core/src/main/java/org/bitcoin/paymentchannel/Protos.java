
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: paymentchannel.proto

package org.bitcoin.paymentchannel;

public final class Protos {
  private Protos() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
  }
  public interface TwoWayChannelMessageOrBuilder extends
      // @@protoc_insertion_point(interface_extends:paymentchannels.TwoWayChannelMessage)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>required .paymentchannels.TwoWayChannelMessage.MessageType type = 1;</code>
     *
     * <pre>
     * This is required so if a new message type is added in future, old software aborts trying
     * to read the message as early as possible. If the message doesn't parse, the socket should
     * be closed.
     * </pre>
     */
    boolean hasType();
    /**
     * <code>required .paymentchannels.TwoWayChannelMessage.MessageType type = 1;</code>
     *
     * <pre>
     * This is required so if a new message type is added in future, old software aborts trying
     * to read the message as early as possible. If the message doesn't parse, the socket should
     * be closed.
     * </pre>
     */
    org.bitcoin.paymentchannel.Protos.TwoWayChannelMessage.MessageType getType();

    /**
     * <code>optional .paymentchannels.ClientVersion client_version = 2;</code>
     *
     * <pre>
     * Now one optional field for each message. Only the field specified by type should be read.
     * </pre>
     */
    boolean hasClientVersion();
    /**
     * <code>optional .paymentchannels.ClientVersion client_version = 2;</code>
     *
     * <pre>
     * Now one optional field for each message. Only the field specified by type should be read.
     * </pre>
     */
    org.bitcoin.paymentchannel.Protos.ClientVersion getClientVersion();
    /**
     * <code>optional .paymentchannels.ClientVersion client_version = 2;</code>
     *
     * <pre>
     * Now one optional field for each message. Only the field specified by type should be read.
     * </pre>
     */
    org.bitcoin.paymentchannel.Protos.ClientVersionOrBuilder getClientVersionOrBuilder();

    /**
     * <code>optional .paymentchannels.ServerVersion server_version = 3;</code>
     */
    boolean hasServerVersion();
    /**
     * <code>optional .paymentchannels.ServerVersion server_version = 3;</code>
     */
    org.bitcoin.paymentchannel.Protos.ServerVersion getServerVersion();
    /**
     * <code>optional .paymentchannels.ServerVersion server_version = 3;</code>
     */
    org.bitcoin.paymentchannel.Protos.ServerVersionOrBuilder getServerVersionOrBuilder();

    /**
     * <code>optional .paymentchannels.Initiate initiate = 4;</code>
     */
    boolean hasInitiate();
    /**
     * <code>optional .paymentchannels.Initiate initiate = 4;</code>
     */
    org.bitcoin.paymentchannel.Protos.Initiate getInitiate();
    /**
     * <code>optional .paymentchannels.Initiate initiate = 4;</code>
     */
    org.bitcoin.paymentchannel.Protos.InitiateOrBuilder getInitiateOrBuilder();

    /**
     * <code>optional .paymentchannels.ProvideRefund provide_refund = 5;</code>
     */
    boolean hasProvideRefund();
    /**
     * <code>optional .paymentchannels.ProvideRefund provide_refund = 5;</code>
     */
    org.bitcoin.paymentchannel.Protos.ProvideRefund getProvideRefund();
    /**
     * <code>optional .paymentchannels.ProvideRefund provide_refund = 5;</code>
     */
    org.bitcoin.paymentchannel.Protos.ProvideRefundOrBuilder getProvideRefundOrBuilder();

    /**
     * <code>optional .paymentchannels.ReturnRefund return_refund = 6;</code>
     */
    boolean hasReturnRefund();
    /**
     * <code>optional .paymentchannels.ReturnRefund return_refund = 6;</code>
     */
    org.bitcoin.paymentchannel.Protos.ReturnRefund getReturnRefund();
    /**
     * <code>optional .paymentchannels.ReturnRefund return_refund = 6;</code>
     */
    org.bitcoin.paymentchannel.Protos.ReturnRefundOrBuilder getReturnRefundOrBuilder();

    /**
     * <code>optional .paymentchannels.ProvideContract provide_contract = 7;</code>
     */
    boolean hasProvideContract();
    /**
     * <code>optional .paymentchannels.ProvideContract provide_contract = 7;</code>
     */
    org.bitcoin.paymentchannel.Protos.ProvideContract getProvideContract();
    /**
     * <code>optional .paymentchannels.ProvideContract provide_contract = 7;</code>
     */
    org.bitcoin.paymentchannel.Protos.ProvideContractOrBuilder getProvideContractOrBuilder();

    /**
     * <code>optional .paymentchannels.UpdatePayment update_payment = 8;</code>
     */
    boolean hasUpdatePayment();
    /**
     * <code>optional .paymentchannels.UpdatePayment update_payment = 8;</code>
     */
    org.bitcoin.paymentchannel.Protos.UpdatePayment getUpdatePayment();
    /**
     * <code>optional .paymentchannels.UpdatePayment update_payment = 8;</code>
     */
    org.bitcoin.paymentchannel.Protos.UpdatePaymentOrBuilder getUpdatePaymentOrBuilder();

    /**
     * <code>optional .paymentchannels.PaymentAck payment_ack = 11;</code>
     */
    boolean hasPaymentAck();
    /**
     * <code>optional .paymentchannels.PaymentAck payment_ack = 11;</code>
     */
    org.bitcoin.paymentchannel.Protos.PaymentAck getPaymentAck();
    /**
     * <code>optional .paymentchannels.PaymentAck payment_ack = 11;</code>
     */
    org.bitcoin.paymentchannel.Protos.PaymentAckOrBuilder getPaymentAckOrBuilder();

    /**
     * <code>optional .paymentchannels.Settlement settlement = 9;</code>
     */
    boolean hasSettlement();
    /**
     * <code>optional .paymentchannels.Settlement settlement = 9;</code>
     */
    org.bitcoin.paymentchannel.Protos.Settlement getSettlement();
    /**
     * <code>optional .paymentchannels.Settlement settlement = 9;</code>
     */
    org.bitcoin.paymentchannel.Protos.SettlementOrBuilder getSettlementOrBuilder();

    /**
     * <code>optional .paymentchannels.Error error = 10;</code>
     */
    boolean hasError();
    /**
     * <code>optional .paymentchannels.Error error = 10;</code>
     */
    org.bitcoin.paymentchannel.Protos.Error getError();
    /**
     * <code>optional .paymentchannels.Error error = 10;</code>
     */
    org.bitcoin.paymentchannel.Protos.ErrorOrBuilder getErrorOrBuilder();
  }
  /**
   * Protobuf type {@code paymentchannels.TwoWayChannelMessage}
   *
   * <pre>
   * This message is designed to be either sent raw over the network (e.g. length prefixed) or embedded inside another
   * protocol that is being extended to support micropayments. In this file "primary" typically can be read as "client"
   * and "secondary" as "server".
   * </pre>
   */
  public static final class TwoWayChannelMessage extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:paymentchannels.TwoWayChannelMessage)
      TwoWayChannelMessageOrBuilder {
    // Use TwoWayChannelMessage.newBuilder() to construct.
    private TwoWayChannelMessage(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
      this.unknownFields = builder.getUnknownFields();
    }
    private TwoWayChannelMessage(boolean noInit) { this.unknownFields = com.google.protobuf.UnknownFieldSet.getDefaultInstance(); }

    private static final TwoWayChannelMessage defaultInstance;
    public static TwoWayChannelMessage getDefaultInstance() {
      return defaultInstance;
    }

    public TwoWayChannelMessage getDefaultInstanceForType() {
      return defaultInstance;
    }

    private final com.google.protobuf.UnknownFieldSet unknownFields;
    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
        getUnknownFields() {
      return this.unknownFields;
    }
    private TwoWayChannelMessage(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      initFields();
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownField(input, unknownFields,
                                     extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 8: {
              int rawValue = input.readEnum();
              org.bitcoin.paymentchannel.Protos.TwoWayChannelMessage.MessageType value = org.bitcoin.paymentchannel.Protos.TwoWayChannelMessage.MessageType.valueOf(rawValue);
              if (value == null) {
                unknownFields.mergeVarintField(1, rawValue);
              } else {
                bitField0_ |= 0x00000001;
                type_ = value;
              }
              break;
            }
            case 18: {
              org.bitcoin.paymentchannel.Protos.ClientVersion.Builder subBuilder = null;
              if (((bitField0_ & 0x00000002) == 0x00000002)) {
                subBuilder = clientVersion_.toBuilder();
              }
              clientVersion_ = input.readMessage(org.bitcoin.paymentchannel.Protos.ClientVersion.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(clientVersion_);
                clientVersion_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000002;
              break;
            }
            case 26: {
              org.bitcoin.paymentchannel.Protos.ServerVersion.Builder subBuilder = null;
              if (((bitField0_ & 0x00000004) == 0x00000004)) {
                subBuilder = serverVersion_.toBuilder();
              }
              serverVersion_ = input.readMessage(org.bitcoin.paymentchannel.Protos.ServerVersion.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(serverVersion_);
                serverVersion_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000004;
              break;
            }
            case 34: {
              org.bitcoin.paymentchannel.Protos.Initiate.Builder subBuilder = null;
              if (((bitField0_ & 0x00000008) == 0x00000008)) {
                subBuilder = initiate_.toBuilder();
              }
              initiate_ = input.readMessage(org.bitcoin.paymentchannel.Protos.Initiate.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(initiate_);
                initiate_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000008;
              break;
            }
            case 42: {
              org.bitcoin.paymentchannel.Protos.ProvideRefund.Builder subBuilder = null;
              if (((bitField0_ & 0x00000010) == 0x00000010)) {
                subBuilder = provideRefund_.toBuilder();
              }
              provideRefund_ = input.readMessage(org.bitcoin.paymentchannel.Protos.ProvideRefund.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(provideRefund_);
                provideRefund_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000010;
              break;
            }
            case 50: {
              org.bitcoin.paymentchannel.Protos.ReturnRefund.Builder subBuilder = null;
              if (((bitField0_ & 0x00000020) == 0x00000020)) {
                subBuilder = returnRefund_.toBuilder();
              }
              returnRefund_ = input.readMessage(org.bitcoin.paymentchannel.Protos.ReturnRefund.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(returnRefund_);
                returnRefund_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000020;
              break;
            }
            case 58: {
              org.bitcoin.paymentchannel.Protos.ProvideContract.Builder subBuilder = null;
              if (((bitField0_ & 0x00000040) == 0x00000040)) {
                subBuilder = provideContract_.toBuilder();
              }
              provideContract_ = input.readMessage(org.bitcoin.paymentchannel.Protos.ProvideContract.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(provideContract_);
                provideContract_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000040;
              break;
            }
            case 66: {
              org.bitcoin.paymentchannel.Protos.UpdatePayment.Builder subBuilder = null;
              if (((bitField0_ & 0x00000080) == 0x00000080)) {
                subBuilder = updatePayment_.toBuilder();
              }
              updatePayment_ = input.readMessage(org.bitcoin.paymentchannel.Protos.UpdatePayment.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(updatePayment_);
                updatePayment_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000080;
              break;
            }
            case 74: {
              org.bitcoin.paymentchannel.Protos.Settlement.Builder subBuilder = null;
              if (((bitField0_ & 0x00000200) == 0x00000200)) {
                subBuilder = settlement_.toBuilder();
              }
              settlement_ = input.readMessage(org.bitcoin.paymentchannel.Protos.Settlement.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(settlement_);
                settlement_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000200;
              break;
            }
            case 82: {
              org.bitcoin.paymentchannel.Protos.Error.Builder subBuilder = null;
              if (((bitField0_ & 0x00000400) == 0x00000400)) {
                subBuilder = error_.toBuilder();
              }
              error_ = input.readMessage(org.bitcoin.paymentchannel.Protos.Error.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(error_);
                error_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000400;
              break;
            }
            case 90: {
              org.bitcoin.paymentchannel.Protos.PaymentAck.Builder subBuilder = null;
              if (((bitField0_ & 0x00000100) == 0x00000100)) {
                subBuilder = paymentAck_.toBuilder();
              }
              paymentAck_ = input.readMessage(org.bitcoin.paymentchannel.Protos.PaymentAck.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(paymentAck_);
                paymentAck_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000100;
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e.getMessage()).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return org.bitcoin.paymentchannel.Protos.internal_static_paymentchannels_TwoWayChannelMessage_descriptor;
    }

    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return org.bitcoin.paymentchannel.Protos.internal_static_paymentchannels_TwoWayChannelMessage_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              org.bitcoin.paymentchannel.Protos.TwoWayChannelMessage.class, org.bitcoin.paymentchannel.Protos.TwoWayChannelMessage.Builder.class);
    }

    public static com.google.protobuf.Parser<TwoWayChannelMessage> PARSER =
        new com.google.protobuf.AbstractParser<TwoWayChannelMessage>() {
      public TwoWayChannelMessage parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new TwoWayChannelMessage(input, extensionRegistry);
      }
    };

    @java.lang.Override
    public com.google.protobuf.Parser<TwoWayChannelMessage> getParserForType() {
      return PARSER;
    }

    /**
     * Protobuf enum {@code paymentchannels.TwoWayChannelMessage.MessageType}
     */
    public enum MessageType
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>CLIENT_VERSION = 1;</code>
       */
      CLIENT_VERSION(0, 1),
      /**
       * <code>SERVER_VERSION = 2;</code>
       */
      SERVER_VERSION(1, 2),
      /**
       * <code>INITIATE = 3;</code>
       */
      INITIATE(2, 3),
      /**
       * <code>PROVIDE_REFUND = 4;</code>
       */
      PROVIDE_REFUND(3, 4),
      /**
       * <code>RETURN_REFUND = 5;</code>
       */
      RETURN_REFUND(4, 5),
      /**
       * <code>PROVIDE_CONTRACT = 6;</code>
       */
      PROVIDE_CONTRACT(5, 6),
      /**
       * <code>CHANNEL_OPEN = 7;</code>
       *
       * <pre>
       * Note that there are no optional fields set for CHANNEL_OPEN, it is sent from the
       * secondary to the primary to indicate that the provided contract was received,
       * verified, and broadcast successfully and the primary can now provide UPDATE messages
       * at will to begin paying secondary. If the channel is interrupted after the
       * CHANNEL_OPEN message (ie closed without an explicit CLOSE or ERROR) the primary may
       * reopen the channel by setting the contract transaction hash in its CLIENT_VERSION
       * message.
       * </pre>
       */
      CHANNEL_OPEN(6, 7),
      /**
       * <code>UPDATE_PAYMENT = 8;</code>
       */
      UPDATE_PAYMENT(7, 8),
      /**
       * <code>PAYMENT_ACK = 11;</code>
       *
       * <pre>
       * Sent by the server to the client after an UPDATE_PAYMENT message is successfully processed.
       * </pre>
       */
      PAYMENT_ACK(8, 11),
      /**
       * <code>CLOSE = 9;</code>
       *
       * <pre>
       * Either side can send this message. If the client sends it to the server, then the server
       * takes the most recent signature it received in an UPDATE_PAYMENT and uses it to create a
       * valid transaction, which it then broadcasts on the network.
       * Once broadcast is complete, it sends back another CLOSE message with the settlement field set, containing
       * the final state of the contract.
       * The server is allowed to initiate settlement whenever it wants, in which case the client will
       * asynchronously receive a CLOSE message with the settlement field set. The server is also allowed
       * to send a CLOSE to mark the end of a connection without any settlement taking place, in which
       * case this is just an equivalent to a TCP FIN packet. An explicit end-of-protocol markers can be
       * useful when this protocol is embedded inside another.
       * </pre>
       */
      CLOSE(9, 9),
      /**
       * <code>ERROR = 10;</code>
       *
       * <pre>
       * Used to indicate an error condition.
       * Both parties should make an effort to send either an ERROR or a CLOSE immediately
       * before closing the socket (unless they just received an ERROR or a CLOSE). This is important
       * because the protocol may not run over TCP.
       * </pre>
       */
      ERROR(10, 10),
      ;

      /**
       * <code>CLIENT_VERSION = 1;</code>
       */
      public static final int CLIENT_VERSION_VALUE = 1;
      /**
       * <code>SERVER_VERSION = 2;</code>
       */
      public static final int SERVER_VERSION_VALUE = 2;
      /**
       * <code>INITIATE = 3;</code>
       */
      public static final int INITIATE_VALUE = 3;
      /**
       * <code>PROVIDE_REFUND = 4;</code>
       */
      public static final int PROVIDE_REFUND_VALUE = 4;
      /**
       * <code>RETURN_REFUND = 5;</code>
       */
      public static final int RETURN_REFUND_VALUE = 5;
      /**
       * <code>PROVIDE_CONTRACT = 6;</code>
       */
      public static final int PROVIDE_CONTRACT_VALUE = 6;
      /**
       * <code>CHANNEL_OPEN = 7;</code>
       *
       * <pre>
       * Note that there are no optional fields set for CHANNEL_OPEN, it is sent from the
       * secondary to the primary to indicate that the provided contract was received,
       * verified, and broadcast successfully and the primary can now provide UPDATE messages
       * at will to begin paying secondary. If the channel is interrupted after the
       * CHANNEL_OPEN message (ie closed without an explicit CLOSE or ERROR) the primary may
       * reopen the channel by setting the contract transaction hash in its CLIENT_VERSION
       * message.
       * </pre>
       */
      public static final int CHANNEL_OPEN_VALUE = 7;
      /**
       * <code>UPDATE_PAYMENT = 8;</code>
       */
      public static final int UPDATE_PAYMENT_VALUE = 8;
      /**
       * <code>PAYMENT_ACK = 11;</code>
       *
       * <pre>
       * Sent by the server to the client after an UPDATE_PAYMENT message is successfully processed.
       * </pre>
       */
      public static final int PAYMENT_ACK_VALUE = 11;
      /**
       * <code>CLOSE = 9;</code>
       *
       * <pre>
       * Either side can send this message. If the client sends it to the server, then the server
       * takes the most recent signature it received in an UPDATE_PAYMENT and uses it to create a
       * valid transaction, which it then broadcasts on the network.
       * Once broadcast is complete, it sends back another CLOSE message with the settlement field set, containing
       * the final state of the contract.
       * The server is allowed to initiate settlement whenever it wants, in which case the client will
       * asynchronously receive a CLOSE message with the settlement field set. The server is also allowed
       * to send a CLOSE to mark the end of a connection without any settlement taking place, in which
       * case this is just an equivalent to a TCP FIN packet. An explicit end-of-protocol markers can be
       * useful when this protocol is embedded inside another.
       * </pre>
       */
      public static final int CLOSE_VALUE = 9;
      /**
       * <code>ERROR = 10;</code>
       *
       * <pre>
       * Used to indicate an error condition.
       * Both parties should make an effort to send either an ERROR or a CLOSE immediately
       * before closing the socket (unless they just received an ERROR or a CLOSE). This is important
       * because the protocol may not run over TCP.
       * </pre>
       */
      public static final int ERROR_VALUE = 10;


      public final int getNumber() { return value; }

      public static MessageType valueOf(int value) {
        switch (value) {
          case 1: return CLIENT_VERSION;
          case 2: return SERVER_VERSION;
          case 3: return INITIATE;
          case 4: return PROVIDE_REFUND;
          case 5: return RETURN_REFUND;
          case 6: return PROVIDE_CONTRACT;
          case 7: return CHANNEL_OPEN;
          case 8: return UPDATE_PAYMENT;
          case 11: return PAYMENT_ACK;
          case 9: return CLOSE;
          case 10: return ERROR;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<MessageType>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static com.google.protobuf.Internal.EnumLiteMap<MessageType>
          internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<MessageType>() {
              public MessageType findValueByNumber(int number) {
                return MessageType.valueOf(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(index);
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return org.bitcoin.paymentchannel.Protos.TwoWayChannelMessage.getDescriptor().getEnumTypes().get(0);
      }

      private static final MessageType[] VALUES = values();

      public static MessageType valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int index;
      private final int value;

      private MessageType(int index, int value) {
        this.index = index;
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:paymentchannels.TwoWayChannelMessage.MessageType)
    }

    private int bitField0_;
    public static final int TYPE_FIELD_NUMBER = 1;
    private org.bitcoin.paymentchannel.Protos.TwoWayChannelMessage.MessageType type_;
    /**
     * <code>required .paymentchannels.TwoWayChannelMessage.MessageType type = 1;</code>
     *
     * <pre>
     * This is required so if a new message type is added in future, old software aborts trying
     * to read the message as early as possible. If the message doesn't parse, the socket should
     * be closed.
     * </pre>
     */
    public boolean hasType() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <code>required .paymentchannels.TwoWayChannelMessage.MessageType type = 1;</code>
     *
     * <pre>
     * This is required so if a new message type is added in future, old software aborts trying
     * to read the message as early as possible. If the message doesn't parse, the socket should
     * be closed.
     * </pre>
     */
    public org.bitcoin.paymentchannel.Protos.TwoWayChannelMessage.MessageType getType() {
      return type_;
    }

    public static final int CLIENT_VERSION_FIELD_NUMBER = 2;
    private org.bitcoin.paymentchannel.Protos.ClientVersion clientVersion_;
    /**
     * <code>optional .paymentchannels.ClientVersion client_version = 2;</code>
     *
     * <pre>
     * Now one optional field for each message. Only the field specified by type should be read.
     * </pre>
     */
    public boolean hasClientVersion() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <code>optional .paymentchannels.ClientVersion client_version = 2;</code>
     *
     * <pre>
     * Now one optional field for each message. Only the field specified by type should be read.
     * </pre>
     */
    public org.bitcoin.paymentchannel.Protos.ClientVersion getClientVersion() {
      return clientVersion_;
    }
    /**
     * <code>optional .paymentchannels.ClientVersion client_version = 2;</code>
     *
     * <pre>
     * Now one optional field for each message. Only the field specified by type should be read.
     * </pre>
     */
    public org.bitcoin.paymentchannel.Protos.ClientVersionOrBuilder getClientVersionOrBuilder() {
      return clientVersion_;
    }

    public static final int SERVER_VERSION_FIELD_NUMBER = 3;
    private org.bitcoin.paymentchannel.Protos.ServerVersion serverVersion_;
    /**
     * <code>optional .paymentchannels.ServerVersion server_version = 3;</code>
     */
    public boolean hasServerVersion() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <code>optional .paymentchannels.ServerVersion server_version = 3;</code>
     */
    public org.bitcoin.paymentchannel.Protos.ServerVersion getServerVersion() {
      return serverVersion_;
    }
    /**
     * <code>optional .paymentchannels.ServerVersion server_version = 3;</code>
     */
    public org.bitcoin.paymentchannel.Protos.ServerVersionOrBuilder getServerVersionOrBuilder() {
      return serverVersion_;
    }

    public static final int INITIATE_FIELD_NUMBER = 4;
    private org.bitcoin.paymentchannel.Protos.Initiate initiate_;
    /**
     * <code>optional .paymentchannels.Initiate initiate = 4;</code>
     */
    public boolean hasInitiate() {
      return ((bitField0_ & 0x00000008) == 0x00000008);
    }
    /**
     * <code>optional .paymentchannels.Initiate initiate = 4;</code>
     */
    public org.bitcoin.paymentchannel.Protos.Initiate getInitiate() {
      return initiate_;
    }
    /**
     * <code>optional .paymentchannels.Initiate initiate = 4;</code>
     */
    public org.bitcoin.paymentchannel.Protos.InitiateOrBuilder getInitiateOrBuilder() {
      return initiate_;
    }

    public static final int PROVIDE_REFUND_FIELD_NUMBER = 5;
    private org.bitcoin.paymentchannel.Protos.ProvideRefund provideRefund_;
    /**
     * <code>optional .paymentchannels.ProvideRefund provide_refund = 5;</code>
     */
    public boolean hasProvideRefund() {
      return ((bitField0_ & 0x00000010) == 0x00000010);
    }
    /**
     * <code>optional .paymentchannels.ProvideRefund provide_refund = 5;</code>
     */
    public org.bitcoin.paymentchannel.Protos.ProvideRefund getProvideRefund() {
      return provideRefund_;
    }
    /**
     * <code>optional .paymentchannels.ProvideRefund provide_refund = 5;</code>
     */
    public org.bitcoin.paymentchannel.Protos.ProvideRefundOrBuilder getProvideRefundOrBuilder() {
      return provideRefund_;
    }

    public static final int RETURN_REFUND_FIELD_NUMBER = 6;
    private org.bitcoin.paymentchannel.Protos.ReturnRefund returnRefund_;
    /**
     * <code>optional .paymentchannels.ReturnRefund return_refund = 6;</code>
     */
    public boolean hasReturnRefund() {
      return ((bitField0_ & 0x00000020) == 0x00000020);
    }
    /**
     * <code>optional .paymentchannels.ReturnRefund return_refund = 6;</code>
     */
    public org.bitcoin.paymentchannel.Protos.ReturnRefund getReturnRefund() {
      return returnRefund_;
    }
    /**
     * <code>optional .paymentchannels.ReturnRefund return_refund = 6;</code>
     */
    public org.bitcoin.paymentchannel.Protos.ReturnRefundOrBuilder getReturnRefundOrBuilder() {
      return returnRefund_;
    }

    public static final int PROVIDE_CONTRACT_FIELD_NUMBER = 7;
    private org.bitcoin.paymentchannel.Protos.ProvideContract provideContract_;
    /**
     * <code>optional .paymentchannels.ProvideContract provide_contract = 7;</code>
     */
    public boolean hasProvideContract() {
      return ((bitField0_ & 0x00000040) == 0x00000040);
    }
    /**
     * <code>optional .paymentchannels.ProvideContract provide_contract = 7;</code>
     */
    public org.bitcoin.paymentchannel.Protos.ProvideContract getProvideContract() {
      return provideContract_;
    }
    /**
     * <code>optional .paymentchannels.ProvideContract provide_contract = 7;</code>
     */
    public org.bitcoin.paymentchannel.Protos.ProvideContractOrBuilder getProvideContractOrBuilder() {
      return provideContract_;
    }

    public static final int UPDATE_PAYMENT_FIELD_NUMBER = 8;
    private org.bitcoin.paymentchannel.Protos.UpdatePayment updatePayment_;
    /**
     * <code>optional .paymentchannels.UpdatePayment update_payment = 8;</code>
     */
    public boolean hasUpdatePayment() {
      return ((bitField0_ & 0x00000080) == 0x00000080);
    }
    /**
     * <code>optional .paymentchannels.UpdatePayment update_payment = 8;</code>
     */
    public org.bitcoin.paymentchannel.Protos.UpdatePayment getUpdatePayment() {
      return updatePayment_;
    }
    /**
     * <code>optional .paymentchannels.UpdatePayment update_payment = 8;</code>
     */
    public org.bitcoin.paymentchannel.Protos.UpdatePaymentOrBuilder getUpdatePaymentOrBuilder() {
      return updatePayment_;
    }

    public static final int PAYMENT_ACK_FIELD_NUMBER = 11;
    private org.bitcoin.paymentchannel.Protos.PaymentAck paymentAck_;
    /**
     * <code>optional .paymentchannels.PaymentAck payment_ack = 11;</code>
     */
    public boolean hasPaymentAck() {
      return ((bitField0_ & 0x00000100) == 0x00000100);
    }
    /**
     * <code>optional .paymentchannels.PaymentAck payment_ack = 11;</code>
     */
    public org.bitcoin.paymentchannel.Protos.PaymentAck getPaymentAck() {
      return paymentAck_;
    }
    /**
     * <code>optional .paymentchannels.PaymentAck payment_ack = 11;</code>
     */
    public org.bitcoin.paymentchannel.Protos.PaymentAckOrBuilder getPaymentAckOrBuilder() {
      return paymentAck_;
    }

    public static final int SETTLEMENT_FIELD_NUMBER = 9;
    private org.bitcoin.paymentchannel.Protos.Settlement settlement_;
    /**
     * <code>optional .paymentchannels.Settlement settlement = 9;</code>
     */
    public boolean hasSettlement() {
      return ((bitField0_ & 0x00000200) == 0x00000200);
    }
    /**
     * <code>optional .paymentchannels.Settlement settlement = 9;</code>
     */
    public org.bitcoin.paymentchannel.Protos.Settlement getSettlement() {
      return settlement_;
    }
    /**
     * <code>optional .paymentchannels.Settlement settlement = 9;</code>
     */
    public org.bitcoin.paymentchannel.Protos.SettlementOrBuilder getSettlementOrBuilder() {
      return settlement_;
    }

    public static final int ERROR_FIELD_NUMBER = 10;
    private org.bitcoin.paymentchannel.Protos.Error error_;
    /**
     * <code>optional .paymentchannels.Error error = 10;</code>
     */
    public boolean hasError() {
      return ((bitField0_ & 0x00000400) == 0x00000400);
    }
    /**
     * <code>optional .paymentchannels.Error error = 10;</code>
     */
    public org.bitcoin.paymentchannel.Protos.Error getError() {
      return error_;
    }
    /**
     * <code>optional .paymentchannels.Error error = 10;</code>
     */
    public org.bitcoin.paymentchannel.Protos.ErrorOrBuilder getErrorOrBuilder() {